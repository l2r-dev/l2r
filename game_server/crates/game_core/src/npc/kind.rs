use crate::{
    attack::Attackable,
    teleport::{self, TeleportListKind},
};
use bevy::{platform::collections::HashMap, prelude::*};
use bevy_enum_tag::EnumComponentTag;
// Expose Components generated by EnumComponentTag
pub use kind::*;
use serde::{
    Deserialize, Deserializer,
    de::{self, MapAccess, Visitor},
};
use std::{fmt, str::FromStr};
use strum::{Display, EnumIter, EnumString};

#[derive(Clone, Debug, Default, Deref, Deserialize, PartialEq, Reflect)]
pub struct TeleporterInfo(HashMap<TeleportListKind, Vec<teleport::Id>>);
impl TeleporterInfo {
    pub fn has_id(&self, id: &teleport::Id) -> bool {
        self.0.values().any(|ids| ids.contains(id))
    }
}

#[derive(
    EnumIter, Default, Clone, Display, Debug, PartialEq, EnumString, Reflect, EnumComponentTag,
)]
#[repr(u32)]
pub enum Kind {
    Adventurer,
    Artefact,
    Auctioneer,
    BabyPet,
    Block,
    BroadcastingTower,
    CastleDoorman,
    Chest,
    ClanHallDoorman,
    ClanHallManager,
    ClassMaster,
    ControlTower,
    DawnPriest,
    Decoy,
    Defender,
    Doorman,
    DuskPriest,
    EffectPoint,
    FeedableBeast,
    FestivalGuide,
    FestivalMonster,
    Fisherman,
    FlameTower,
    FlyTerrainObject,
    FortCommander,
    FortLogistics,
    FortManager,
    #[default]
    Friendly,
    FriendlyMob,
    #[require(Attackable)]
    GrandBoss,
    Guard,
    Merchant,
    #[require(Attackable)]
    Monster,
    OlympiadManager,
    Pet,
    PetManager,
    QuestGuard,
    RaceManager,
    #[require(Attackable)]
    RaidBoss,
    #[require(Attackable)]
    RaidMinion,
    RiftInvader,
    SepulcherMonster,
    SepulcherNpc,
    Servitor,
    SignsPriest,
    TamedBeast,
    Teleporter(Option<TeleporterInfo>),
    TerrainObject,
    TerritoryWard,
    Trainer,
    VillageMasterDarkElf,
    VillageMasterDwarf,
    VillageMasterElf,
    VillageMasterFighter,
    VillageMasterHuman,
    VillageMasterMystic,
    VillageMasterOrc,
    VillageMasterPriest,
    VillageMasterKamael,
    Warehouse,
    FortDoorman,
}

impl<'de> Deserialize<'de> for Kind {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        struct KindVisitor;

        impl<'de> Visitor<'de> for KindVisitor {
            type Value = Kind;

            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                formatter.write_str("A string or an object representing a Kind")
            }

            fn visit_str<E>(self, value: &str) -> Result<Self::Value, E>
            where
                E: de::Error,
            {
                // Special case to return None when it's just a string
                if value == "Teleporter" {
                    return Ok(Kind::Teleporter(None));
                }

                // Use strum's FromStr implementation for all other variants
                Kind::from_str(value).map_err(|_| {
                    de::Error::unknown_variant(value, &["Use one of the npc::Kind variants"])
                })
            }

            // Handle the object format ex.: "kind": {"Teleporter": {"all": [1,2,3], "noble": [4,5,6]}}
            fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
            where
                A: MapAccess<'de>,
            {
                if let Some((key, value)) = map.next_entry::<String, serde_json::Value>()? {
                    match key.as_str() {
                        "Teleporter" => {
                            let teleporter_info: TeleporterInfo =
                                serde_json::from_value(value).map_err(de::Error::custom)?;
                            Ok(Kind::Teleporter(Some(teleporter_info)))
                        }
                        // For other variants, we just use the string value
                        variant => self.visit_str(variant),
                    }
                } else {
                    Err(de::Error::custom("expected a non-empty object"))
                }
            }
        }

        deserializer.deserialize_any(KindVisitor)
    }
}
